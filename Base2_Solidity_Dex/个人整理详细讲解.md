## 协议中的用户类型

1. 流动性提供者 (Liquidity Provider, LP)

目的: 赚取交易手续费和套利收益。他们将资产锁定在特定的价格区间内。

主要交互合约: PositionManager

主要操作:  
Mint: 存入 $\text{token0}$ 和 $\text{token1}$，创建并获得一个代表其流动性份额的 $\text{NFT}$ $(\text{positionId})$。  
Burn: 移除 $\text{NFT}$ 所代表的流动性 ($\text{L}$)，将本金和累积的手续费收益结算到头寸的内部记账变量 ($\text{tokensOwed}$)。  
Collect: 从 $\text{Pool}$ 中提取已结算的本金和手续费收益。

2. 普通交易用户 (Swapper)

目的: 将一种代币兑换成另一种代币（例如，用 $\text{ETH}$ 换 $\text{USDC}$）。

主要交互合约: SwapRouter

主要操作:  
exactInput: 提供精确的输入量，获取尽可能多的输出量（最常用）。  
exactOutput: 提供精确的输出量，消耗尽可能少的输入量。  
报价 (quoteExactInput/quoteExactOutput): 模拟交易以确定汇率，不实际执行链上转账。

## 三个主要模块的调用流程图：流动性提供 (Mint)、代币交换 (Swap)、以及流动性移除和收益提取 (Burn & Collect)

1. 流动性提供（Mint）流程

这个流程描述了用户如何通过 $\text{PositionManager}$ 存入代币，铸造一个 $\text{NFT}$ 流动性头寸，并将资产转移到 $\text{Pool}$ 中。


|步骤|合约|函数|描述
|---|----|----|----|
|0. 准备|User/EIP712|approve|用户授权 PositionManager 转移 token0 和 token1。|
|1. 启动|User→PositionManager|mint|用户调用 mint，传入代币数量、tick 边界等参数。|
|2. 查找|PositionManager→PoolManager|getPool|查找对应的 Pool 地址。|
|3. 计算|PositionManager→LiquidityAmounts|getLiquidityForAmounts|根据用户的输入代币数量和 Pool 价格，计算出可铸造的流动性 L。|
|4. 委托|PositionManager→Pool|mint|PositionManager 调用 Pool.mint，要求 Pool 记录 L 并触发回调。|
|5. 回调 (Pull)|Pool→PositionManager|mintCallback|Pool 在记录 L 后，立即回调 PositionManager。|
|6. 转移资产|PositionManager|transferFrom|在回调中，PositionManager 将 amount0/amount1 从用户钱包拉取到 Pool 合约。|
|7. 铸造 NFT|PositionManager|_mint (ERC721)|铸造新的 NFT (positionId) 给用户，并记录 PositionInfo 及费用快照。|
|8. 完成|PositionManager|returns|返回 positionId 和实际存入的 amount0/amount1。|

2. 代币交换（Swap）流程

这个流程描述了用户如何通过 $\text{SwapRouter}$ 执行代币交换，这也是一个使用回调机制的 拉取代币（Pull Token） 模式。


|步骤|合约|函数|描述|
|---|----|----|----|
|0. 准备|User/EIP712|approve|用户授权 SwapRouter 转移 tokenIn。|
|1. 启动|User→SwapRouter|exactInput|用户调用 exactInput，发起交易，指定输入量 amountIn。|
|2. 查找|SwapRouter→PoolManager|getPool|查找交易路径中的第一个 Pool。|
|3. 委托|SwapRouter→Pool|swap|Router 调用 Pool.swap，指定输入量 amountIn 和接收地址 recipient。|
|4. 计算|Pool|SwapMath|Pool 执行价格和流动性计算，确定需要多少 tokenIn (实际消耗量) 才能得到 tokenOut (实际产出量)。|
|5. 回调 (Pull)|Pool→SwapRouter|swapCallback|Pool 在计算完消耗量后，立即回调 Router，要求支付 tokenIn。|
|6. 转移资产|SwapRouter|transferFrom|在回调中，Router 将实际消耗的 tokenIn 从用户钱包拉取到 Pool 合约。|
|7. 产出|Pool|transfer|Pool 在收到输入代币后，将计算得到的 tokenOut 转移给 recipient。|
|8. 完成|SwapRouter|returns|Router 确认 amountOut 满足滑点要求，并返回实际获得的 amountOut。|


3. 流动性移除和收益提取（Burn & Collect）流程

这个流程将移除流动性 (Burn) 和提取资产 (Collect) 分离，允许 LP 先销毁 $\text{L}$，将本金和收益结算到记账变量 $(\text{tokensOwed})$, 然后再进行提现操作。

|步骤|合约|函数|描述
|---|----|----|----|
|A1. 移除流动性|User→PositionManager|burn|用户调用 burn，指定 positionId。|
|A2. 委托移除|PositionManager→Pool|burn|PositionManager 委托 Pool 移除该头寸的 L。|
|A3. 结算记账|PositionManager|Update PositionInfo|"burn 不转移资产。它将 Pool 返回的本金 (amount0| amount1) 和累积的手续费收益，全部加到 PositionInfo 的 tokensOwed 字段中，并设置 liquidity=0。"|
|B1. 提取资产|User→PositionManager|collect|用户调用 collect，指定 positionId 和 recipient。|
|B2. 委托提取|PositionManager→Pool|collect|PositionManager 调用 Pool.collect，要求 Pool 转移 tokensOwed 字段中的资产。|
|B3. 转移资产|Pool|transfer|Pool 将 token0/token1 从其合约地址转移到 recipient 地址。|
|B4. 销毁 NFT|PositionManager|_burn (ERC721)|如果 liquidity 为 0 (已 burn) 且 tokensOwed 清零，则销毁 NFT。|